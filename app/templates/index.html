<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto-Flow: Unified Analysis Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chart.js/3.9.1/chart.min.js "></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js "></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/locale/de.min.js "></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css " rel="stylesheet"/>
    <link rel="stylesheet" href="/static/style.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- TransactionVisualizer Code -->
    <script>

        // Aktualisiere die trackTransactions Funktion
        // In index.html, ersetze die trackTransactions Funktion:
        async function trackTransactions() {
            const startTx = document.getElementById('startTx').value;
            const targetCurrency = document.getElementById('targetCurrency').value;
            const numTransactions = parseInt(document.getElementById('numTransactions').value, 10);
            
            if (!startTx) {
                showError('Bitte geben Sie eine Starttransaktion ein.');
                return;
            }
            
            showLoading();
            
            try {
                const response = await fetch(`${API_BASE_URL}/track-transactions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        start_tx_hash: startTx,
                        target_currency: targetCurrency,
                        num_transactions: numTransactions
                    })
                });
        
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Netzwerk-Antwort war nicht ok');
                }
        
                const data = await response.json();
                
                // Konvertiere das API-Response-Format in das erwartete Format
                const formattedData = {
                    source_currency: data.source_currency,
                    target_currency: data.target_currency,
                    start_transaction: data.start_transaction,
                    transactions_count: data.transactions_count,
                    transactions: data.transactions.map(tx => ({
                        ...tx,
                        timestamp: tx.timestamp || Date.now() / 1000,
                        inputs: tx.value ? [{ value: tx.value, value_converted: tx.value_converted }] : [],
                        fee: tx.fee || 0
                    }))
                };
        
                // Visualisiere die Daten
                TransactionVisualizer.visualizeTransactions(formattedData, 'transactionTree');
        
            } catch (error) {
                console.error('Fehler beim Abrufen der Transaktionsdaten:', error);
                showError('Transaktionsdaten konnten nicht abgerufen werden: ' + error.message);
            }
        }
        
        // Füge diese Hilfsfunktion hinzu
        function shortenAddress(address) {
            if (!address) return '';
            return address.length > 12 ? 
                `${address.substring(0, 6)}...${address.substring(address.length - 4)}` : 
                address;
        }
        
        // Füge die createSVGTreeFromSOLTransaction Funktion hinzu
        function createSVGTreeFromSOLTransaction(transaction, targetCurrency) {
            const width = 800;
            const height = 400;
            
            return `
                <svg width="${width}" height="${height}" class="transaction-tree">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                            refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="${currencyColors.sol}"/>
                        </marker>
                    </defs>
                    
                    <!-- Transaktionsfluss -->
                    <g class="transaction-flow">
                        <line x1="${width/4}" y1="${height/2}"
                              x2="${width*3/4}" y2="${height/2}"
                              stroke="${currencyColors.sol}" 
                              stroke-width="2"
                              marker-end="url(#arrowhead)"/>
                    </g>
        
                    <!-- Quell-Wallet -->
                    <g class="wallet-node source" transform="translate(${width/4}, ${height/2})">
                        <circle r="30" fill="${currencyColors.sol}"/>
                        <text y="50" text-anchor="middle" class="wallet-label">
                            ${shortenAddress(transaction.from_address || '')}
                        </text>
                    </g>
        
                    <!-- Ziel-Wallet -->
                    <g class="wallet-node target" transform="translate(${width*3/4}, ${height/2})">
                        <circle r="30" fill="${currencyColors[targetCurrency.toLowerCase()]}"/>
                        <text y="50" text-anchor="middle" class="wallet-label">
                            ${shortenAddress(transaction.to_address || '')}
                        </text>
                    </g>
        
                    <!-- Transaktionsdetails -->
                    <g class="transaction-details" transform="translate(${width/2}, ${height/4})">
                        <text text-anchor="middle" class="transaction-value">
                            ${transaction.value} SOL
                        </text>
                        <text y="20" text-anchor="middle" class="transaction-hash">
                            ${shortenAddress(transaction.hash)}
                        </text>
                    </g>
                </svg>
            `;
        }

        
        const TransactionVisualizer = (function() {
            // Private Variablen und Hilfsfunktionen
            const currencyColors = {
                btc: '#f2a900',
                eth: '#627eea',
                sol: '#00ffbd'
            };

            function showLoading(container) {
                container.innerHTML = '';
                container.className = 'loading';
            }

            function showError(container, message) {
                container.classList.remove('loading');
                container.innerHTML = `<div class="error-message">${message}</div>`;
            }

            function updateInfoPanels(data) {
                // Start-Informationen
                document.getElementById('sourceCurrency').textContent = data.source_currency || '-';
                document.getElementById('sourceCurrency').className = 'transaction-value value-' + (data.source_currency || '').toLowerCase();
                document.getElementById('startHash').textContent = data.start_transaction || '-';
                
                const startTime = data.transactions && data.transactions[0] ? 
                    new Date(data.transactions[0].timestamp * 1000).toLocaleString() : '-';
                document.getElementById('startTime').textContent = startTime;
                
                // Transaktionsstatistik aktualisieren
                document.getElementById('txCount').textContent = data.transactions_count || 0;
                
                let totalValue = 0;
                let totalFees = 0;
                
                if (data.transactions && data.transactions.length > 0) {
                    if (data.transactions[0].currency === 'BTC') {
                        totalValue = data.transactions[0].inputs.reduce((sum, input) => sum + input.value, 0);
                    }
                    totalFees = data.transactions.reduce((sum, tx) => sum + (tx.fee || 0), 0);
                }
                
                document.getElementById('totalValue').textContent = 
                    `${totalValue.toFixed(8)} ${data.source_currency}`;
                document.getElementById('totalValue').className = 
                    `transaction-value value-${(data.source_currency || '').toLowerCase()}`;
                    
                document.getElementById('totalFees').textContent = 
                    `${totalFees.toFixed(8)} ${data.source_currency}`;
                document.getElementById('totalFees').className = 
                    `transaction-value value-${(data.source_currency || '').toLowerCase()}`;
                
                // Konvertierungsinformationen
                document.getElementById('targetCurrencyDisplay').textContent = data.target_currency || '-';
                document.getElementById('targetCurrencyDisplay').className = 
                    `transaction-value value-${(data.target_currency || '').toLowerCase()}`;
                
                let exchangeRate = 1.0;
                if (data.transactions && data.transactions[0] && data.transactions[0].inputs && data.transactions[0].inputs[0]) {
                    const input = data.transactions[0].inputs[0];
                    if (input.value > 0 && input.value_converted) {
                        exchangeRate = input.value_converted / input.value;
                    }
                }
                
                document.getElementById('exchangeRate').textContent = 
                    `1 ${data.source_currency} = ${exchangeRate.toFixed(4)} ${data.target_currency}`;
                    
                const convertedValue = totalValue * exchangeRate;
                document.getElementById('convertedValue').textContent = 
                    `${convertedValue.toFixed(4)} ${data.target_currency}`;
                document.getElementById('convertedValue').className = 
                    `transaction-value value-${(data.target_currency || '').toLowerCase()}`;
            }

           function visualizeTransactionFlow(data) {
                const container = document.getElementById('transactionTree');
                const width = container.clientWidth;
                const height = 600;
            
                // D3 Force-Layout Setup
                const simulation = d3.forceSimulation(data.flow_tree.nodes)
                    .force('link', d3.forceLink(data.flow_tree.edges)
                        .id(d => d.address)
                        .distance(100))
                    .force('charge', d3.forceManyBody().strength(-300))
                    .force('center', d3.forceCenter(width / 2, height / 2));
            
                // SVG Setup
                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);
            
                // Definiere Pfeilspitzen
                svg.append('defs').selectAll('marker')
                    .data(['standard', 'swap', 'split', 'merge'])
                    .enter().append('marker')
                    .attr('id', d => `arrow-${d}`)
                    .attr('viewBox', '0 -5 10 10')
                    .attr('refX', 15)
                    .attr('refY', 0)
                    .attr('markerWidth', 6)
                    .attr('markerHeight', 6)
                    .attr('orient', 'auto')
                    .append('path')
                    .attr('d', 'M0,-5L10,0L0,5')
                    .attr('fill', d => getTransactionColor(d));
            
                // Zeichne Verbindungen
                const link = svg.append('g')
                    .selectAll('line')
                    .data(data.flow_tree.edges)
                    .enter().append('line')
                    .attr('stroke-width', d => Math.sqrt(d.value))
                    .attr('stroke', d => getCurrencyColor(d.currency))
                    .attr('marker-end', d => `url(#arrow-${d.type})`);
            
                // Zeichne Nodes
                const node = svg.append('g')
                    .selectAll('g')
                    .data(data.flow_tree.nodes)
                    .enter().append('g')
                    .call(d3.drag()
                        .on('start', dragstarted)
                        .on('drag', dragged)
                        .on('end', dragended));
            
                // Node Kreise
                node.append('circle')
                    .attr('r', d => getNodeSize(d))
                    .attr('fill', d => getCurrencyColor(d.currency));
            
                // Node Labels
                node.append('text')
                    .text(d => shortenAddress(d.address))
                    .attr('x', 6)
                    .attr('y', 3);
            
                // Tooltip
                const tooltip = d3.select(container)
                    .append('div')
                    .attr('class', 'tooltip')
                    .style('opacity', 0);
            
                // Update-Funktion
                simulation.on('tick', () => {
                    link
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);
            
                    node
                        .attr('transform', d => `translate(${d.x},${d.y})`);
                });
            }
            
                // Aktualisiere Positionen
                simulation.on('tick', () => {
                    links
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);
            
                    nodes
                        .attr('transform', d => `translate(${d.x},${d.y})`);
                });
            }

            // Füge die neue Funktion hier ein
            function createSVGTreeFromSOLTransaction(transaction, targetCurrency) {
                const width = 800;
                const height = 400;
                const padding = 40;
                
                let svgContent = `
                <svg width="${width}" height="${height}" class="transaction-tree">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                            refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#00ffbd"/>
                        </marker>
                    </defs>
                    
                    <!-- Transaction Flow -->
                    <g class="transaction-flow">
                        <line x1="${padding + 200}" y1="${height/2}"
                              x2="${width - padding - 200}" y2="${height/2}"
                              stroke="#00ffbd" stroke-width="2"
                              marker-end="url(#arrowhead)"/>
                    </g>
            
                    <!-- Source Transaction Box -->
                    <g class="transaction-node source">
                        <rect x="${padding}" y="${height/2 - 40}" 
                              width="200" height="80" 
                              class="node-rect value-sol" 
                              rx="5" ry="5"/>
                        <text x="${padding + 100}" y="${height/2 - 20}" 
                              class="node-text" text-anchor="middle">
                            Source Transaction
                        </text>
                        <text x="${padding + 100}" y="${height/2}" 
                              class="node-text" text-anchor="middle">
                            ${transaction.hash.substring(0, 15)}...
                        </text>
                        <text x="${padding + 100}" y="${height/2 + 20}" 
                              class="node-value" text-anchor="middle">
                            ${transaction.value || 0} SOL
                        </text>
                    </g>
            
                    <!-- Target Transaction Box (if exists) -->
                    <g class="transaction-node target">
                        <rect x="${width - padding - 200}" y="${height/2 - 40}" 
                              width="200" height="80" 
                              class="node-rect value-${targetCurrency.toLowerCase()}" 
                              rx="5" ry="5"/>
                        <text x="${width - padding - 100}" y="${height/2 - 20}" 
                              class="node-text" text-anchor="middle">
                            Target Currency
                        </text>
                        <text x="${width - padding - 100}" y="${height/2}" 
                              class="node-text" text-anchor="middle">
                            ${targetCurrency}
                        </text>
                        <text x="${width - padding - 100}" y="${height/2 + 20}" 
                              class="node-value" text-anchor="middle">
                            ${transaction.value_converted || transaction.value || 0} ${targetCurrency}
                        </text>
                    </g>
            
                    <!-- Transaction Details -->
                    <g class="transaction-details">
                        <!-- Timestamp -->
                        <text x="${padding}" y="${padding}" 
                              class="timestamp-text" text-anchor="start">
                            ${new Date(transaction.timestamp * 1000).toLocaleString()}
                        </text>
                        
                        <!-- Fee -->
                        <text x="${width - padding}" y="${height - padding}" 
                              class="fee-text" text-anchor="end">
                            Fee: ${transaction.fee} SOL
                        </text>
                    </g>
                </svg>`;
                
                return svgContent;
            }
            // Öffentliche API
            return {
                showLoading: function(containerId) {
                    const container = document.getElementById(containerId);
                    showLoading(container);
                },
                
                showError: function(containerId, message) {
                    const container = document.getElementById(containerId);
                    showError(container, message);
                },
                
                visualizeTransactions: function(data, containerId) {
                    const container = document.getElementById(containerId);
                    
                    if (!data || !data.transactions || data.transactions.length === 0) {
                        showError(container, 'Keine Transaktionsdaten verfügbar.');
                        return;
                    }
                    
                    updateInfoPanels(data);
                    
                    container.classList.remove('loading');
                    createTransactionTree(data, container);
                },
                
                setCurrencyColors: function(colors) {
                    if (colors.btc) currencyColors.btc = colors.btc;
                    if (colors.eth) currencyColors.eth = colors.eth;
                    if (colors.sol) currencyColors.sol = colors.sol;
                }
            };
        })();

        window.TransactionVisualizer = TransactionVisualizer;
    </script>

    <!-- Main Application Code -->
    <script>
        const API_BASE_URL = '/api/v1';

        document.addEventListener('DOMContentLoaded', function() {
            initializeTabs();
            initTransactionTracker();
            initSocialAnalysis();
            initializeDates();
        });

        function initializeTabs() {
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabId = this.getAttribute('data-tab');
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                    document.getElementById(tabId).classList.add('active');
                });
            });
        }

        function initializeDates() {
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('start_date').value = today;
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            document.getElementById('end_date').value = tomorrow.toISOString().split('T')[0];
        }

        function initTransactionTracker() {
            document.getElementById('trackButton').addEventListener('click', trackTransactions);
        }

        async function trackTransactions() {
            const startTx = document.getElementById('startTx').value;
            const targetCurrency = document.getElementById('targetCurrency').value;
            const numTransactions = parseInt(document.getElementById('numTransactions').value, 10);
            
            if (!startTx) {
                showError('Bitte geben Sie eine Starttransaktion ein.');
                return;
            }
            
            showLoading();
            
            try {
                // Echter API-Aufruf statt Sample-Daten
                const response = await fetch(`${API_BASE_URL}/track-transactions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        start_tx_hash: startTx,
                        target_currency: targetCurrency,
                        num_transactions: numTransactions
                    })
                });
        
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);
                }
        
                const data = await response.json();
                visualizeTransactions(data);
            } catch (error) {
                console.error('Fehler beim Abrufen der Transaktionsdaten:', error);
                showError(`Transaktionsdaten konnten nicht abgerufen werden: ${error.message}`);
            }
        }

        function visualizeTransactions(data) {
            TransactionVisualizer.visualizeTransactions(data, 'transactionTree');
        }

        function showLoading() {
            TransactionVisualizer.showLoading('transactionTree');
        }

        function showError(message) {
            TransactionVisualizer.showError('transactionTree', message);
        }

        function initSocialAnalysis() {
            document.getElementById('analysisForm').addEventListener('submit', submitAnalysis);
        }

        async function submitAnalysis(event) {
            event.preventDefault();
            
            // Get the blockchain value
            const blockchain = document.getElementById('blockchain').value.toLowerCase();
            const contractAddress = document.getElementById('contract_address').value.trim();
            
            // Validate contract address
            if (!contractAddress) {
                document.getElementById('result').innerHTML = `
                    <h3>Fehler!</h3>
                    <p>Contract-Adresse ist erforderlich.</p>
                `;
                document.getElementById('result').style.display = 'block';
                return;
            }
        
            // Validate contract address format based on blockchain
            if (["ethereum", "binance", "polygon"].includes(blockchain)) {
                if (!contractAddress.startsWith('0x') || contractAddress.length !== 42) {
                    document.getElementById('result').innerHTML = `
                        <h3>Fehler!</h3>
                        <p>${blockchain}-Adressen müssen mit 0x beginnen und 42 Zeichen lang sein.</p>
                    `;
                    document.getElementById('result').style.display = 'block';
                    return;
                }
            } else if (blockchain === "solana") {
                if (contractAddress.length !== 44) {
                    document.getElementById('result').innerHTML = `
                        <h3>Fehler!</h3>
                        <p>Solana-Adressen müssen 44 Zeichen lang sein.</p>
                    `;
                    document.getElementById('result').style.display = 'block';
                    return;
                }
            }
            
            try {
                const formData = {
                    blockchain: blockchain,
                    contract_address: contractAddress,
                    twitter_username: document.getElementById('twitter_username').value.trim(),
                    keywords: document.getElementById('keywords').value.split(',').map(k => k.trim()).filter(Boolean),
                    start_date: document.getElementById('start_date').value,
                    end_date: document.getElementById('end_date').value,
                    tweet_limit: parseInt(document.getElementById('tweet_limit').value, 10)
                };
        
                const resultDiv = document.getElementById('result');
                resultDiv.style.display = 'block'; // Make sure this is set
                resultDiv.innerHTML = '<h3>Analyse wird gestartet...</h3>';
        
                // Add debug logging
                console.log('Sending analysis request:', formData);
        
                const response = await fetch(`${API_BASE_URL}/analyze/rule-based`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'  // Add Accept header
                    },
                    body: JSON.stringify(formData)
                });
        
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);
                }
        
                const data = await response.json();
                const jobId = data.job_id;
                
                // Add debug logging
                console.log('Analysis started:', data);
        
                resultDiv.innerHTML = `
                    <h3>Analyse erfolgreich gestartet!</h3>
                    <p><strong>Job-ID:</strong> ${jobId}</p>
                    <p><strong>Status:</strong> ${data.status}</p>
                `;
        
                // Start polling
                simulatePolling(jobId);
        
            } catch (error) {
                console.error('Error submitting analysis:', error);
                document.getElementById('result').innerHTML = `
                    <h3>Fehler!</h3>
                    <p>${error.message}</p>
                `;
            }
        }

        
        async function simulatePolling(jobId) {
            const resultDiv = document.getElementById('result');
            let retries = 0;
            const maxRetries = 30; // Stop after 1 minute (30 * 2 seconds)
            
            const interval = setInterval(async () => {
                try {
                    retries++;
                    const status = await getAnalysisStatus(jobId);
                    
                    // Add debug logging
                    console.log('Poll status:', status);
        
                    if (status.status === "Completed" || status.status.startsWith("Failed")) {
                        clearInterval(interval);
                        
                        resultDiv.innerHTML = `
                            <h3>${status.status === "Completed" ? "Analyse abgeschlossen!" : "Analyse fehlgeschlagen"}</h3>
                            <p><strong>Job-ID:</strong> ${jobId}</p>
                            <p><strong>Status:</strong> ${status.status}</p>
                            ${status.status === "Completed" ? `
                            <div class="analysis-results">
                                <h4>Gefundene Wallet-Adressen:</h4>
                                ${status.potential_wallets && status.potential_wallets.length > 0 
                                    ? `<ul>${status.potential_wallets.map(wallet => `<li>${wallet}</li>`).join('')}</ul>`
                                    : '<p>Keine Wallet-Adressen gefunden.</p>'
                                }
                                <p><strong>Analysierte Tweets:</strong> ${status.analyzed_tweets || 0}</p>
                                <p><strong>Analysierte Transaktionen:</strong> ${status.analyzed_transactions || 0}</p>
                            </div>
                            ` : ''}
                        `;
                    } else if (retries >= maxRetries) {
                        clearInterval(interval);
                        resultDiv.innerHTML = `
                            <h3>Zeitüberschreitung</h3>
                            <p>Die Analyse dauert länger als erwartet. Bitte überprüfen Sie später den Status.</p>
                            <p><strong>Job-ID:</strong> ${jobId}</p>
                        `;
                    } else {
                        resultDiv.innerHTML = `
                            <h3>Analyse läuft...</h3>
                            <p><strong>Job-ID:</strong> ${jobId}</p>
                            <p><strong>Status:</strong> ${status.status}</p>
                        `;
                    }
                } catch (error) {
                    console.error('Error polling status:', error);
                    if (retries >= maxRetries) {
                        clearInterval(interval);
                        resultDiv.innerHTML = `
                            <h3>Fehler!</h3>
                            <p>Fehler beim Abrufen des Analyse-Status: ${error.message}</p>
                        `;
                    }
                }
            }, 2000);
        }

        async function getAnalysisStatus(jobId) {
            try {
                const response = await fetch(`${API_BASE_URL}/analysis/status/${jobId}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error('Fehler beim Abrufen des Status:', error);
                throw error;
            }
        }

        function generateSampleData(startTx, targetCurrency, numTransactions) {
            // This is a placeholder function to generate sample data
            // In a real implementation, this would be replaced by actual API calls
            return {
                source_currency: "BTC",
                target_currency: targetCurrency,
                start_transaction: startTx,
                transactions_count: numTransactions,
                transactions: [{
                    currency: "BTC",
                    timestamp: Date.now() / 1000,
                    inputs: [{ value: 1.0, value_converted: 1.5 }],
                    fee: 0.0001
                }]
            };
        }
    </script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">Crypto-Flow: Unified Analysis Dashboard</h1>
            <button class="refresh-btn" id="refreshBtn">
                <i class="fas fa-sync-alt"></i>
            </button>
        </div>
        <div class="tabs">
            <div class="tab active" data-tab="transaction-tracker">Transaction Tracker</div>
            <div class="tab" data-tab="social-analysis">Social Analysis</div>
        </div>
        
        <!-- Transaction Tracker Tab -->
        <div class="tab-content active" id="transaction-tracker">
            <div class="controls">
                <div class="control-item">
                    <label for="startTx">Starttransaktion:</label>
                    <input type="text" id="startTx" placeholder="Transaktions-Hash eingeben" style="width: 100%;">
                </div>
                <div class="control-item">
                    <label for="targetCurrency">Zielwährung:</label>
                    <select id="targetCurrency">
                        <option value="BTC">BTC</option>
                        <option value="ETH">ETH</option>
                        <option value="SOL" selected>SOL</option>
                    </select>
                </div>
                <div class="control-item">
                    <label for="numTransactions">Anzahl Transaktionen:</label>
                    <input type="number" id="numTransactions" min="1" max="100" value="10">
                </div>
                <div class="control-item">
                    <button id="trackButton" style="width: 100%;">Transaktionen verfolgen</button>
                </div>
            </div>
            <div class="info-panel">
                <div class="info-card">
                    <h3>Start-Informationen</h3>
                    <div id="startInfo">
                        <div class="transaction-item">
                            <span>Währung:</span>
                            <span id="sourceCurrency" class="transaction-value">-</span>
                        </div>
                        <div class="transaction-item">
                            <span>Hash:</span>
                            <span id="startHash" class="transaction-value" style="word-break: break-all; font-size: 0.9em;">-</span>
                        </div>
                        <div class="transaction-item">
                            <span>Zeitstempel:</span>
                            <span id="startTime" class="transaction-value">-</span>
                        </div>
                    </div>
                </div>
                <div class="info-card">
                    <h3>Transaktionsstatistik</h3>
                    <div id="txStats">
                        <div class="transaction-item">
                            <span>Anzahl verfolgt:</span>
                            <span id="txCount" class="transaction-value">-</span>
                        </div>
                        <div class="transaction-item">
                            <span>Gesamtwert:</span>
                            <span id="totalValue" class="transaction-value">-</span>
                        </div>
                        <div class="transaction-item">
                            <span>Gesamtgebühren:</span>
                            <span id="totalFees" class="transaction-value">-</span>
                        </div>
                    </div>
                </div>
                <div class="info-card">
                    <h3>Konvertierung</h3>
                    <div id="conversionInfo">
                        <div class="transaction-item">
                            <span>Zielwährung:</span>
                            <span id="targetCurrencyDisplay" class="transaction-value">-</span>
                        </div>
                        <div class="transaction-item">
                            <span>Wechselkurs:</span>
                            <span id="exchangeRate" class="transaction-value">-</span>
                        </div>
                        <div class="transaction-item">
                            <span>Wert in Zielwährung:</span>
                            <span id="convertedValue" class="transaction-value">-</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="visualization">
                <div id="transactionTree" class="loading"></div>
            </div>
        </div>
        
        <!-- Social Analysis Tab -->
        <div class="tab-content" id="social-analysis">
            <form id="analysisForm" onsubmit="event.preventDefault(); submitAnalysis();">
                <div>
                    <label for="blockchain">Blockchain:</label>
                    <select id="blockchain" required>
                        <option value="ethereum">Ethereum</option>
                        <option value="binance">Binance</option>
                        <option value="polygon">Polygon</option>
                        <option value="solana">Solana</option>
                    </select>
                    <small>Wählen Sie die Blockchain aus, z. B. Ethereum oder Solana.</small>
                </div>
                <div>
                    <label for="contract_address">Contract-Adresse:</label>
                    <input id="contract_address" type="text" 
                           placeholder="z.B. 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984" 
                           required>
                    <small>Geben Sie die eindeutige Adresse des Smart Contracts ein.</small>
                </div>
                <div>
                    <label for="twitter_username">Twitter-Benutzername:</label>
                    <input id="twitter_username" type="text" placeholder="z.B. @example" required>
                    <small>Geben Sie den Twitter-Benutzernamen der Person oder des Projekts ein, das analysiert werden soll.</small>
                </div>
                <div>
                    <label for="keywords">Keywords (durch Komma getrennt):</label>
                    <input id="keywords" type="text" placeholder="z.B. Uniswap, UNI, DEX" required>
                    <small>Geben Sie Schlüsselwörter ein, um relevante Tweets zu finden, z. B. Projektnamen oder Token.</small>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <div>
                        <label for="start_date">Startdatum:</label>
                        <input id="start_date" type="date" required>
                    </div>
                    <div>
                        <label for="end_date">Enddatum:</label>
                        <input id="end_date" type="date" required>
                    </div>
                </div>
                <div>
                    <label for="tweet_limit">Tweet-Limit:</label>
                    <input id="tweet_limit" type="number" min="10" max="5000" value="100">
                    <small>Die maximale Anzahl an Tweets, die analysiert werden sollen (10 bis 5000).</small>
                </div>
                <button type="submit">Analyse starten</button>
            </form>
            <div id="result" style="display: none;"></div>
        </div>
    </div>
</body>
</html>
